<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Poly Maker Dashboard</title>
    <base href="/poly-maker/">
    <link rel="stylesheet" href="static/styles.css" />
  </head>
  <body>
    <div class="container">
      <div class="header-row">
        <h1>Poly Maker Dashboard</h1>
        <a id="total-pnl" class="pill" href="pnl" title="View per-trade PnL">PnL: —</a>
      </div>

      <section>
        <h2>Open Orders</h2>
        <table id="orders">
          <thead>
            <tr>
              <th>Market</th>
              <th>Outcome</th>
              <th>Side</th>
              <th>Price</th>
              <th>Orig Size</th>
              <th>Matched</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>

      <section>
        <h2>Positions</h2>
        <div class="positions-header">
          <button id="close-all-btn" class="btn btn-pill btn-danger">Close All Positions</button>
        </div>
        <table id="positions">
          <thead>
            <tr>
              <th>Market</th>
              <th>Outcome</th>
              <th>Size</th>
              <th>Avg Price</th>
              <th>Cur Price</th>
              <th>PnL %</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="positions-tbody"></tbody>
        </table>
      </section>

      <section>
        <h2>Last Trades</h2>
        <table id="trades">
          <thead>
            <tr>
              <th>Market</th>
              <th>Outcome</th>
              <th>Side</th>
              <th>Shares</th>
              <th>Price</th>
              <th>Time</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div class="pagination" id="pagination"></div>
      </section>
    </div>

    <script>
      async function fetchJson(url) {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error('Request failed: ' + url);
        return res.json();
      }

      function setRows(tbody, rows, columns) {
        tbody.innerHTML = '';
        console.log('setRows called for:', tbody.id, 'with', rows.length, 'rows');
        
        for (const row of rows) {
          const tr = document.createElement('tr');
          for (const c of columns) {
            const td = document.createElement('td');
            let v = row[c];
            if (typeof v === 'number') {
              v = Math.abs(v) > 1e6 ? v.toFixed(2) : v;
            }
            td.textContent = v == null ? '' : v;
            tr.appendChild(td);
          }
          
          // Add actions column for positions table
          if (tbody.id === 'positions-tbody') {
            // Try to find the asset/token ID from various possible field names
            const assetId = row.asset || row.token_id || row.tokenId || row.asset_id;
            
            if (assetId) {
              const actionsTd = document.createElement('td');
              actionsTd.className = 'actions-cell';
              
              const group = document.createElement('div');
              group.className = 'action-group';
              
              // Create price input
              const priceInput = document.createElement('input');
              priceInput.type = 'number';
              priceInput.step = '0.01';
              priceInput.min = '0.01';
              priceInput.max = '0.99';
              priceInput.placeholder = 'Limit';
              priceInput.title = 'Limit price (0.01-0.99)';
              priceInput.className = 'price-input';
              
              // Create close at limit button
              const closeLimitBtn = document.createElement('button');
              closeLimitBtn.textContent = 'Limit';
              closeLimitBtn.className = 'btn btn-pill btn-primary btn-sm';
              closeLimitBtn.onclick = () => closePosition(assetId, parseFloat(priceInput.value), [closeLimitBtn, closeMarketBtn]);
              
              // Create close at market button
              const closeMarketBtn = document.createElement('button');
              closeMarketBtn.textContent = 'Market';
              closeMarketBtn.className = 'btn btn-pill btn-warning btn-sm';
              closeMarketBtn.onclick = () => closePosition(assetId, null, [closeLimitBtn, closeMarketBtn]);
              
              group.appendChild(priceInput);
              group.appendChild(closeLimitBtn);
              group.appendChild(closeMarketBtn);
              actionsTd.appendChild(group);
              tr.appendChild(actionsTd);
            } else {
              // Add empty actions cell for consistency
              const actionsTd = document.createElement('td');
              actionsTd.textContent = 'No asset ID';
              actionsTd.className = 'actions-cell';
              tr.appendChild(actionsTd);
            }
          }
          
          tbody.appendChild(tr);
        }
      }

      // Function to close a specific position
      async function closePosition(tokenId, price, buttons) {
        try {
          const payload = { token_id: tokenId };
          if (price !== null && !isNaN(price)) {
            payload.price = price;
          }
          if (Array.isArray(buttons)) {
            buttons.forEach(b => b && (b.disabled = true));
          }
          
          const response = await fetch('api/positions/close', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload)
          });
          
          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to close position');
          }
          
          const result = await response.json();
          alert(`Success: ${result.message}`);
          
          // Refresh the dashboard to show updated positions
          refresh();
          
        } catch (error) {
          console.error('Error closing position:', error);
          alert(`Error: ${error.message}`);
        } finally {
          if (Array.isArray(buttons)) {
            buttons.forEach(b => b && (b.disabled = false));
          }
        }
      }

      // Function to close all positions
      async function closeAllPositions() {
        if (!confirm('Are you sure you want to close ALL positions? This will submit aggressive market orders.')) {
          return;
        }
        
        try {
          const allBtn = document.getElementById('close-all-btn');
          if (allBtn) allBtn.disabled = true;
          const response = await fetch('api/positions/close', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({})
          });
          
          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to close all positions');
          }
          
          const result = await response.json();
          alert(`Success: ${result.message}`);
          
          // Refresh the dashboard to show updated positions
          refresh();
          
        } catch (error) {
          console.error('Error closing all positions:', error);
          alert(`Error: ${error.message}`);
        } finally {
          const allBtn = document.getElementById('close-all-btn');
          if (allBtn) allBtn.disabled = false;
        }
      }

      let tradePage = 1;
      const tradesPerPage = 10;

      function makeButton(label, page, disabled=false, active=false) {
        const btn = document.createElement('button');
        btn.textContent = label;
        if (disabled) btn.disabled = true;
        if (active) btn.className = 'active';
        if (!disabled && !active && typeof page === 'number') {
          btn.addEventListener('click', () => { tradePage = page; refresh(); });
        }
        return btn;
      }

      function renderPagination(totalPages) {
        const container = document.getElementById('pagination');
        container.innerHTML = '';
        // Prev
        container.appendChild(makeButton('<', tradePage - 1, tradePage <= 1));

        const pages = [];
        if (totalPages <= 5) {
          for (let p = 1; p <= totalPages; p++) pages.push(p);
        } else {
          pages.push(1);
          if (tradePage > 3) pages.push('…');
          const start = Math.max(2, tradePage - 1);
          const end = Math.min(totalPages - 1, tradePage + 1);
          for (let p = start; p <= end; p++) pages.push(p);
          if (tradePage < totalPages - 2) pages.push('…');
          pages.push(totalPages);
        }

        for (const p of pages) {
          if (p === '…') {
            const span = document.createElement('span');
            span.textContent = '…';
            container.appendChild(span);
          } else {
            container.appendChild(makeButton(String(p), p, false, p === tradePage));
          }
        }

        // Next
        container.appendChild(makeButton('>', tradePage + 1, tradePage >= totalPages));
      }

      async function refresh() {
        try {
          const [ordRes, posRes, trRes, pnlRes] = await Promise.allSettled([
            fetchJson('api/orders'),
            fetchJson('api/positions'),
            fetchJson(`api/trades?limit=${tradesPerPage}&page=${tradePage}`),
            fetchJson('api/pnl'),
          ]);

          const orders = ordRes.status === 'fulfilled' ? ordRes.value : { data: [] };
          const positions = posRes.status === 'fulfilled' ? posRes.value : { data: [] };
          const trades = trRes.status === 'fulfilled' ? trRes.value : { data: [], total: 0 };
          const pnl = pnlRes.status === 'fulfilled' ? pnlRes.value : { total: 0 };

          setRows(document.querySelector('#orders tbody'), orders.data || [], [
            'market_name', 'outcome', 'side', 'price', 'original_size', 'size_matched', 'status'
          ]);
          setRows(
            document.querySelector('#positions-tbody'),
            positions.data || [],
            ['market_name', 'outcome', 'size', 'avgPrice', 'curPrice', 'percentPnl']
          );
          setRows(document.querySelector('#trades tbody'), trades.data || [], [
            'market_name', 'outcome', 'side', 'size', 'price', 'datetime'
          ]);
          const totalPages = trades.total ? Math.max(1, Math.ceil(trades.total / tradesPerPage)) : 1;
          renderPagination(totalPages);

          // Update header PnL pill
          const pill = document.getElementById('total-pnl');
          const total = pnl && typeof pnl.total === 'number' ? pnl.total : 0;
          const sign = total > 0 ? '+' : '';
          pill.textContent = `PnL: ${sign}${total.toFixed(2)}`;
          pill.classList.remove('green', 'red');
          pill.classList.add(total >= 0 ? 'green' : 'red');
        } catch (e) {
          console.error(e);
        }
      }

      // Setup event listener for close all button
      document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('close-all-btn').addEventListener('click', closeAllPositions);
      });

      refresh();
      setInterval(refresh, 5000);
    </script>
  </body>
</html>


