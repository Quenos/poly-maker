## Strategy Exploit Analysis (Polymarket MM)

This document outlines how other traders can exploit predictable behaviors in the market-making strategy by trading against the bot, and practical mitigations aligned with existing patterns.

### Relevant mechanics

- Fair price derives from token1 order book; token2 is mirrored as 1 - mid(token1).
- Spread: h = k_vol·sigma + k_fee_ticks·tick; quotes are layered with geometric size growth and per-tick jitter.
- Engine avoids mass cancels; replaces on age, partial fill, or mid shift; BUYs are gated by min price and position cap; SELLs reduce inventory.

Key references:

```382:410:mm/market_maker.py
# Builds desired quotes from token1 fair, mirrors token2; BUY capacity enforced
```

```699:785:mm/market_maker.py
# DesiredQuote construction, min_buy_price gating, capacity budget
```

```146:175:mm/orders.py
# Replacement/placement rules; avoids mass cancels
```

```91:160:mm/market_data.py
# Fair prices; parity from token1
```

```95:141:mm/strategy.py
# Layered quotes: geometric size growth, jitter, monotonic ladder
```

### Exploit scenarios

1) Top-of-book spoofing to steer quotes
- Preconditions: thin/medium top-of-book; requote threshold low; fair derived from token1 best levels.
- Playbook:
  1. Post a small spoof order at token1 best ask (or best bid) to move mid/microprice by ≥1 tick.
  2. Wait 1–2 snapshots for the bot to move its reservation price or replace bids/asks toward the spoofed level.
  3. Cancel spoof immediately.
  4. Instantly sell into the bot’s now-elevated bid (or buy from its lowered ask).
- Bot symptoms: higher replacement logs without corresponding trade prints; quotes chase flickering best levels.
- Profit mechanism: adverse selection on shifted quotes; repeatable with low inventory impact for the attacker.

2) Tick-flip replacement churn
- Preconditions: `requote_mid_ticks` ≈ 1; short `order_max_age_sec`; replace does not cancel old first.
- Playbook:
  1. Alternate token1 best levels by ±1 tick using tiny orders (can self-trade to flip if allowed).
  2. Each flip triggers replacement due to mid shift/age, creating a new order closer to mid.
  3. Hit the newly placed order before older orders are pruned, harvesting edge repeatedly.
- Bot symptoms: elevated `actions.replaced`, `placed` spikes; partial fills near mid with frequent tiny losses.
- Profit mechanism: farm micro-edge from newly placed quotes and transient duplication of exposure.

3) Stale deep liquidity pick-off
- Preconditions: engine avoids mass cancels; desired layers can shrink while live orders remain; deep layers use larger sizes (geometric growth).
- Playbook:
  1. Let the bot build a deeper ladder (e.g., during quiet times or after widening).
  2. Nudge conditions so desired layers shrink (e.g., reduce mid volatility, cause capacity gating), leaving older deep quotes live.
  3. Later sweep those stale deep orders with a targeted market order when they are misaligned with current fair.
- Bot symptoms: fills on older order IDs at deeper levels; loss concentrated in deeper layers.
- Profit mechanism: time-delayed sweep of oversized deep quotes at favorable prices.

4) Token2 mispricing via token1 mirroring
- Preconditions: token2 book temporarily diverges from strict parity; strategy prices token2 as 1 - mid(token1) without consulting token2 book.
- Playbook:
  1. Slightly push token1 best levels to move mid by 1–2 ticks (cheap if book is thin).
  2. Immediately lift token2 side that becomes rich under mirroring (e.g., NO becomes underpriced).
  3. Revert token1 to original state; repeat as divergence reappears.
- Bot symptoms: profitable hits on token2 while token1 appears balanced; parity alerts may not trigger if within ε.
- Profit mechanism: cross-leg arbitrage exploiting one-sided fair computation.

5) Event/news jump pick-offs
- Preconditions: sudden information arrival; EWMA/fair smoothing; spreads widen only after sigma/markout catch up.
- Playbook:
  1. At news release, immediately lift the bot’s quotes anchored to pre-jump fair.
  2. Exit after bot widens or re-centers; rinse/repeat on subsequent microbursts.
- Bot symptoms: clustered losses preceding increases in computed sigma/spread; fills just before widening.
- Profit mechanism: pick off stale quotes in the lag window before adaptive widening.

6) Buy-cap herding
- Preconditions: `max_position_shares` enforced on BUY with open-buy accounting; SELLs not similarly capped.
- Playbook:
  1. Gradually sell small sizes into the bot’s bids until cap is reached on a token.
  2. The bot cancels BUYs and stops adding bid support; liquidity on the downside thins.
  3. Push price lower to exit shorts or reaccumulate cheaper; repeat across tokens.
- Bot symptoms: frequent cap-reached cancellations; reduced bid presence; subsequent unfavorable price drift.
- Profit mechanism: reduce opposing liquidity by forcing caps, then move market through the gap.

7) Cold-start/backfill bias
- Preconditions: missing/lagging WS snapshot; REST backfill seeds initial book; best levels can be transient.
- Playbook:
  1. Time order placement when a token (re)subscribes or after disconnects.
  2. Briefly set favorable best levels that the REST backfill captures as initial snapshot.
  3. Hit resulting quotes built from biased fair before live WS updates normalize.
- Bot symptoms: early-cycle fills after reconnect/backfill; logs show backfill followed by immediate orders engine activity.
- Profit mechanism: exploit the first-quote bias on cold start.

8) Volatility inflation via flicker
- Preconditions: sigma feeds off price changes; k_vol scales h with sigma.
- Playbook:
  1. Rapidly flicker best levels with tiny size to inflate observed volatility.
  2. The bot widens spreads and/or reduces effective size via risk multipliers.
  3. Quote inside the widened spread to capture organic flow at better economics.
- Bot symptoms: increased computed sigma and h without corresponding depth/trade prints; lower hit rate.
- Profit mechanism: reduce competition by forcing the bot to be less competitive while attacker stays tight.

### Low-friction mitigations

Short-term (minimal code changes):

- Replacement stability gate
  - Require mid shift to persist for N consecutive samples (or over T ms) before replacing; still replace on age.

- Cancel overflow beyond desired layers
  - If live orders per side exceed desired layers, cancel farthest orders until counts match.

- Replacement cooldown per token
  - Enforce a small per-token cooldown (e.g., ≥2–3s) between replacements.

- Depth-weighted fair/TWAP
  - Weight by top-k sizes and apply a short TWAP to reduce spoof impact.

- Token2 sanity check
  - Blend token2’s own top-of-book into mirrored price or require parity within ε before fully quoting both sides.

- Flatten deep size growth
  - Reduce geometric growth to ≤1.2× per level or cap deep sizes to limit sweep loss.

- Minimum live time before replace
  - Do not replace an order younger than T seconds unless mid moved ≥2 ticks.

- Place-then-cancel for replace
  - After placing the replacement, cancel the mapped old order to avoid duplicate exposure.

Medium effort (still fits current structure):

- Queue-aware replacements
  - Replace only if it improves depth from mid by ≥Z ticks.

- Anti-spoof hysteresis
  - Require best level persistence or minimum size threshold to influence fair.

- Event-aware spread/size
  - Temporarily widen h and reduce size when trades/minute spikes; decay back gradually.

Safeguards to keep:

- Min BUY price floor, position cap with open-buy accounting, over-cap cancels, daily loss/IOC reductions via RiskManager.

### Suggested edit points

- `mm/orders.py`: Cancel overflow beyond desired layers; adjust replace to place-then-cancel.
- `mm/market_maker.py`: Add per-token replacement cooldown and stability checks before `engine.sync`.
- `mm/market_data.py::fair_prices`: Depth-weighted mid and brief EMA/TWAP; parity alerts retained.
- `mm/strategy.py::build_layered_quotes`: Reduce deep size growth or cap deep sizes.

### KPIs to monitor

- First-layer hit ratio; fill PnL by depth; replacement rate per token; sweep loss per incident; token2 parity divergence; count of excess live orders (should drop to ~0).

### Priority

- Highest impact vs cost: cancel excess deep orders and add token2 sanity checks. These two materially reduce pick-offs and parity exploits with minimal churn.


